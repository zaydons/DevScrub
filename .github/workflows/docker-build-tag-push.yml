name: Build, Tag, and Push Docker Image

on:
  push:
    branches:
      - '**'
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all platforms'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: devscrub
  DOCKER_BUILDKIT: 1

# Define workflow permissions
permissions:
  contents: read
  packages: write

# Prevent multiple builds from running simultaneously
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      docker: ${{ steps.filter.outputs.docker }}
      python: ${{ steps.filter.outputs.python }}
      node: ${{ steps.filter.outputs.node }}
      force_build: ${{ steps.force.outputs.force_build }}
    steps:
      - uses: actions/checkout@v4
      - name: Check for force-build flag in PR title
        id: force
        if: github.event_name == 'pull_request'
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          if [[ "$TITLE" == *"[force-build]"* ]]; then
            echo "force_build=true" >> $GITHUB_OUTPUT
          else
            echo "force_build=false" >> $GITHUB_OUTPUT
          fi
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            docker:
              - 'Dockerfile'
              - 'docker-compose.yml'
              - '.dockerignore'
            python:
              - 'requirements.txt'
              - 'src/**/*.py'
              - 'scripts/**/*.py'
            node:
              - 'package.json'
              - 'package-lock.json'
              - 'yarn.lock'
              - 'src/**/*.js'
              - 'src/**/*.ts'

  build-strategy:
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.docker == 'true' || needs.changes.outputs.python == 'true' || needs.changes.outputs.node == 'true' || github.event.inputs.force_rebuild == 'true' || needs.changes.outputs.force_build == 'true'
    outputs:
      platforms: ${{ steps.strategy.outputs.platforms }}
      tags: ${{ steps.tags.outputs.tags }}
      version: ${{ steps.version.outputs.version }}
      build_args: ${{ steps.build_args.outputs.build_args }}
      force_build: ${{ needs.changes.outputs.force_build }}
    steps:
      - uses: actions/checkout@v4
      - name: Extract version and metadata
        id: version
        run: |
          VERSION=$(cat VERSION | tr -d ' \n')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
          echo "git_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "git_ref=${{ github.ref }}" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
      - name: Determine build strategy
        id: strategy
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event_name }}" == "release" ]]; then
            echo 'platforms=["linux/amd64","linux/arm64"]' >> $GITHUB_OUTPUT
            echo "Selected platforms: linux/amd64, linux/arm64"
          else
            echo 'platforms=["linux/amd64"]' >> $GITHUB_OUTPUT
            echo "Selected platforms: linux/amd64"
          fi
      - name: Set Docker tags
        id: tags
        run: |
          BRANCH=${GITHUB_REF##*/}
          TAGS="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH"
          if [ "$BRANCH" = "main" ]; then
            TAGS="$TAGS,${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest"
          fi
          if [ "${{ github.event_name }}" = "release" ]; then
            TAGS="$TAGS,${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"
          fi
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
      - name: Prepare build arguments
        id: build_args
        run: |
          echo "VERSION=${{ env.VERSION }}" >> $GITHUB_OUTPUT
          echo "BUILD_DATE=${{ steps.version.outputs.build_date }}" >> $GITHUB_OUTPUT
          echo "GIT_SHA=${{ steps.version.outputs.git_sha }}" >> $GITHUB_OUTPUT
          echo "GIT_REF=${{ steps.version.outputs.git_ref }}" >> $GITHUB_OUTPUT

  build:
    needs: [changes, build-strategy]
    if: needs.changes.outputs.docker == 'true' || needs.changes.outputs.python == 'true' || needs.changes.outputs.node == 'true' || github.event.inputs.force_rebuild == 'true' || needs.changes.outputs.force_build == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: ${{ fromJson(needs.build-strategy.outputs.platforms) }}
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:v0.12.0
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}-${{ matrix.platform }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ github.sha }}-
            ${{ runner.os }}-buildx-
      - name: Debug build environment
        run: |
          echo "üîç Debugging build environment for platform: ${{ matrix.platform }}"
          echo "Build args:"
          echo "  VERSION: ${{ needs.build-strategy.outputs.VERSION }}"
          echo "  BUILD_DATE: ${{ needs.build-strategy.outputs.BUILD_DATE }}"
          echo "  GIT_SHA: ${{ needs.build-strategy.outputs.GIT_SHA }}"
          echo "  GIT_REF: ${{ needs.build-strategy.outputs.GIT_REF }}"
          echo "Tags: ${{ needs.build-strategy.outputs.tags }}"
          echo "Labels: ${{ steps.meta.outputs.labels }}"
          echo "Platform: ${{ matrix.platform }}"
          docker version
          docker buildx version
          
          # Test Dockerfile syntax
          echo "üîç Testing Dockerfile syntax..."
          docker buildx build --dry-run --platform ${{ matrix.platform }} . || echo "Dockerfile syntax check failed"
          
          # Check if all required files exist
          echo "üìÅ Checking required files..."
          ls -la
          echo "üìÑ Checking Dockerfile..."
          head -20 Dockerfile
          echo "üìÑ Checking requirements.txt..."
          cat requirements.txt
      - name: Build and push
        id: build
        run: |
          echo "üî® Building for platform: ${{ matrix.platform }}"
          echo "üìã Build args:"
          echo "  VERSION: ${{ needs.build-strategy.outputs.VERSION }}"
          echo "  BUILD_DATE: ${{ needs.build-strategy.outputs.BUILD_DATE }}"
          echo "  GIT_SHA: ${{ needs.build-strategy.outputs.GIT_SHA }}"
          echo "  GIT_REF: ${{ needs.build-strategy.outputs.GIT_REF }}"
          echo "  TAGS: ${{ needs.build-strategy.outputs.tags }}"
          
          # Parse tags and build command
          TAGS="${{ needs.build-strategy.outputs.tags }}"
          TAG_ARGS=""
          IFS=',' read -ra TAG_ARRAY <<< "$TAGS"
          for tag in "${TAG_ARRAY[@]}"; do
            TAG_ARGS="$TAG_ARGS --tag $tag"
          done
          
          echo "üîß Tag arguments: $TAG_ARGS"
          
          # Build with detailed output and error capture
          set -o pipefail
          docker buildx build \
            --platform ${{ matrix.platform }} \
            $TAG_ARGS \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --build-arg VERSION=${{ needs.build-strategy.outputs.VERSION }} \
            --build-arg BUILD_DATE=${{ needs.build-strategy.outputs.BUILD_DATE }} \
            --build-arg GIT_SHA=${{ needs.build-strategy.outputs.GIT_SHA }} \
            --build-arg GIT_REF=${{ needs.build-strategy.outputs.GIT_REF }} \
            --provenance=true \
            --sbom=true \
            --push \
            . 2>&1 | tee build.log
          
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          echo "üîç Build completed with exit code: $BUILD_EXIT_CODE"
          
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Build failed! Full build log:"
            cat build.log
            exit $BUILD_EXIT_CODE
          else
            echo "‚úÖ Build completed successfully!"
          fi
      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
        continue-on-error: true


  verify:
    needs: [build-strategy, build]
    if: needs.build.result == 'success' && needs.build-strategy.outputs.platforms != ''
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: ${{ fromJson(needs.build-strategy.outputs.platforms) }}
    permissions:
      packages: read
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Verify image functionality
        run: |
          echo "Verifying image for platform: ${{ matrix.platform }}"
          
          # Get the branch name for the tag
          BRANCH=${GITHUB_REF##*/}
          
          # Pull the built image using the branch tag
          docker pull ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH
          
          # Test basic functionality by overriding entrypoint
          docker run --rm --entrypoint python ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH --version
          docker run --rm --entrypoint node ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH --version
          
          echo "‚úÖ Image verification successful for ${{ matrix.platform }}"

  manifest:
    needs: [build-strategy, build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'release'
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Create and push manifest
        run: |
          echo "Creating multi-architecture manifest..."
          BRANCH=${GITHUB_REF##*/}
          
          # Only create manifest if we have multiple platforms
          PLATFORMS=$(echo '${{ needs.build-strategy.outputs.platforms }}' | jq -r 'join(",")')
          if [[ "$PLATFORMS" == *"linux/arm64"* ]]; then
            # Get the digests of the built images for both platforms
            AMD64_DIGEST=$(docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH --format '{{.Manifest.Digest}}')
            ARM64_DIGEST=$(docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH --format '{{.Manifest.Digest}}')
            
            # Create manifest for version tag with platform info
            docker buildx imagetools create -t ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ needs.build-strategy.outputs.VERSION }} \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH@$AMD64_DIGEST \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH@$ARM64_DIGEST
            
            # Create manifest for latest tag if on main branch
            if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
              docker buildx imagetools create -t ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest \
                ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH@$AMD64_DIGEST \
                ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$BRANCH@$ARM64_DIGEST
            fi
          else
            echo "Single platform build, skipping manifest creation"
          fi

  tag:
    needs: [build-strategy, build, manifest]
    if: always() && needs.build.result != 'failure'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up git
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
      - name: Create tags
        run: |
          BRANCH=${GITHUB_REF##*/}
          VERSION=${{ needs.build-strategy.outputs.VERSION }}
          
          # Force create/update tags (this will overwrite existing tags)
          git tag -f "$BRANCH"
          echo "Created/updated tag: $BRANCH"
          
          git tag -f "v$VERSION"
          echo "Created/updated tag: v$VERSION"
          
          if [ "$BRANCH" = "main" ]; then
            git tag -f latest
            echo "Created/updated tag: latest"
          fi
          
          # Force push tags
          git push origin --tags --force

  notify:
    needs: [build-strategy, build, verify, tag]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Build status
        run: |
          if [ "${{ needs.build.result }}" = "success" ] && [ "${{ needs.verify.result }}" = "success" ]; then
            echo "‚úÖ Build completed successfully!"
            echo "üì¶ Images pushed to: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}"
            echo "üè∑Ô∏è  Tags created for version: ${{ needs.build-strategy.outputs.VERSION }}"
          elif [ "${{ needs.build.result }}" = "failure" ]; then
            echo "‚ùå Build failed!"
            echo "Build result: ${{ needs.build.result }}"
            echo "Please check the build logs for detailed error information."
            exit 1
          else
            echo "‚ö†Ô∏è  Build completed with warnings"
            echo "Build result: ${{ needs.build.result }}"
            echo "Verify result: ${{ needs.verify.result }}"
          fi 